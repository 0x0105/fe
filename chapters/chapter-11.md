那些年，我使用的前端优化的奇技淫巧
===

> 我开始写前端应用的时候，并不知道一个 Web 应用需要优化那么多的东西。编写应用的时候，运行在本地的机器上，没有网络问题，也没有多少的性能问题。可当我把自己写的博客部署到服务器上时，我才发现原来我的应用在生产环境上这么脆弱。

我的第一个真正意义上的 Web 应用——开发完应用，并可供全世界访问，是我的博客。它运行在一个共享 256 M 内存的 VPS 服务器上，并且服务器是在国外，受限于网络没有备案的缘故。于是，在这个配置不怎样的、并且在国外的机器上，打开我的博客可是要好几分钟。

因此，我便不断地想着办法去优化打开速度，在边学习前端知识的时候，也边玩着各种 Web 运维的知识。直到我毕业的时候，我才有财力将博客迁往 Amazon 的AWS 上，才大大降低了应用的打开速度。

虽然处理速度上去了，带宽等条件也没有好多少。随着能力的提供，发现最开始觉得的服务器又在国外、解析域名 DNS 影响了网站打开速度，还有一系列的问题需要优化。

所以，它给我的第一个经验是：**当更好的服务器可以解决问题时，就不会花费人力了。**

后来吧，随着对于 Web 开发了解的深入，我开始对这性能优化有了更深入的了解。

博客优化经验：速度优化
---

当我的博客迁移到 AWS，服务器的性能提升之后，我便开始着手解决网络带来的问题。因此，首先就是要确认问题到底是来自网络的哪一部分。这时，我们就可以借助于 Chrome 浏览器，来查看一下问题的来源。

打开 Chrome 浏览器的 Network 标签，点击最后的 **Waterfall** 就可以看到相应的内容：

![Chrome 网络工具](network-performance.png)

从图中，我们就可以看到影响加载速度的主要因素是：

 - Waiting (TTFB)。TTFB，即Time To First Byte，指的是：请求发出后，到收到响应的第一个字节所花费的时间。
 - Content Download。即下载内容所需要的时间。

用户下载内容所需要的时间，受限于服务器的资源、资源的大小以及用户的网络速度。因此，我们暂时不讨论这方面的内容。

我们可以看到这里的主要限制因素是，TTFB。而要对 TTFB 优化的话，就需要关心两部分：

 - 服务器。比如：如果有复杂的防火墙规则或路由问题，则TTFB时间可能很大。又或者是你的服务器性能不好，但是你启用了 GZIP 压缩，那么它也将增加 TTFB 所需要的时间。
 - 应用程序。比较简单的作法是和我一样，交这部分交给 New Relic 去处理，我们就可以知道应用中哪些地方比较占用资源。

### TTFB 优化

而对于早期我的博客来说，还有一个主要的限制因素是 DNS 查询所需要的时间——即查询这个域名对应的服务器地址的时间。这主要是受限于**域名服务器提供的 DNS 服务器比较慢**，作一个比较简单的对比：

![淘宝 vs www.phodal.com](ping-results.png)

通过使用 ``traceroute`` 工具，我们就可以发现经过不同网关所需要的时间了：

![traceroute 结果](traceroute.png)

而这还是在我采用了 DNSPod 这样的工具之后的结果，原先的域名服务器则需要更长的时间。可惜，我这么穷已经不能付钱给更好的 DNS 服务提供商了。

### 服务器优化

后来，我发现我的博客还有一个瓶颈是在服务器上。于是，我使用 APM 工具 NewRelic 发现了另外一个性能瓶颈，服务器默认使用的 Python 版本是 2.6。

对于如我博客这样性能的服务器来说，应用的一个很大的瓶颈就是：大量的数据查询。如当用户访问博客的列表页时，大概需要 400+ ms 左右的时间，而一篇详情页则差不多是 100ms+。

而在当时，我并没有注意博客对于缓存的控制，主要是因为使用的静态资源比较少。这一点直到我实习的时候才发现。

### 项目优化

JSON -> API -> 压缩，一个请求特别慢，300kb 左右的 JSON 文件

体积变化 -> GitHub -> 解压时间


因此也练就了一些奇技淫巧 -> 缓存  JavaScript 文件

### 反模式

为了更好的优化，我采用了一些反模式。这些模式违背了业界推荐的 ”最佳实践“

inline.js inline.css inline

最佳实践往往是成本最高的

         | 成本
         |
         |
最好      |          最差
-------------------->
         |
         |
         | 低成本

业界最高的 AMP，就是一个例子 style in html,

###  缓存 API 结果 

-> 体验优化

-> 移动 web -> 混合应用 -> 页面切换 -> 列表 -> 详细 
       								  返回 缓存数据


生命周期 lifecycle

componentWillUpdate

componentDidMount

移动桌面与 Web 的区别：先 API 后进入页面，先进入页面，再获取数据 








前后端分离的 API 的正确打开姿势：设计、使用及维护
===

作为一个程序员，我讨厌那些没有文档的库，当一个库没有文档的时候，它也不会有测试。

如果一个 API 有测试，那么它也相当于有一份简单的文档了——如果我们可以看到测试代码的话。

因为交付周期的原因，接入了一个第三方的库，遇到了这么一些问题：文档老旧，并且不够全面。

当我们在做一个前后端分离的项目时，我们就经常遇到这样的问题。**API 的维护是一件烦人的事，所以在设计之前，你已经设计好你需要什么内容。

API是协作完成的
---

API 设计实际上应该是由前端人员来驱动的。后台只提高你想要的数据，而不是反过来的。后台提供数据，你从中选择你需要的内容。

我们常报怨后台 API 设计得不合理，主要便是因为后台不知道前端需要什么内容。

这就好像你接到了一个需求，而 UX 或者美工给老板见过设计图，但是并没有给你看。你能设计出符合需求的界面吗？

答案，不用想也知道。

因此，当你把 API 的设计交给后台的时候，也就意味着这个 API 将更符合后台的需求。那么它的设计就趋向于对后台更简单的结果，比如后台返回给你一个 Unix 时间，而你需要的是一个标准时间。又或者是反过来的，你需要的是一个 Unix 时间，而后台返回给你的是当地的时间。

与此同时，按前端人员的假设，我们也会做类似的、『不正确』的 API 设计。

因此，这种活动便像是一个博弈。

API 设计
---

前端 <-> 契约 <-> 后台

URL + 参数 返回结果

JSON Web Token

HTTP 请求 <-> 服务端数据 

HTTP 请求 <-> 缓存 <-> 服务端数据 

HTTP 请求 <-> 代理 <-> 服务端数据 

HTTP 请求 <-> 缓存 <-> 代理 <-> 服务端数据 


约定
---

Swagger

方式

 - 契约即测试代码（contract as code）
 - API 即文档（api as document）


设计原则 
---

交给后台完成的情形：

 - 前端、应用端使用同一套 API，那么当出现 API 前后端皆可时，应该交给后台。这是从工作量的计算上来看的，后台实现这个功能一天，移动端、前端各一天，那么就应该交由后台去做。Time is money.



